<?php
/**
 * @file
 * A module to enable jquery calendar multiselect picker.
 *
 * Requires the Date Popup module.
 *
 * Add a type of #date_multiselect to any date or datetime field that will
 * use this widget. Set #date_format to the way the date should be presented
 * to the user in the form. Set #default_value to be a date in the local
 * timezone, and note the timezone name in #date_timezone.
 *
 * No time elements are included in the format string, only the date
 * will be saved.
 */

/**
 * Implements hook_field_widget_info().
 */
function date_multiselect_field_widget_info() {
  $settings = array(
    'settings' => array(
      'input_format' => date_default_format('date_select'),
      'input_format_custom' => '',
      'increment' => 15,
      'text_parts' => array(),
      'year_range' => '-3:+3',
      'numberOfMonths' => '2',
    ),
    'behaviors' => array(
      'default value' => FIELD_BEHAVIOR_NONE,
      'multiple values' => FIELD_BEHAVIOR_CUSTOM,
    ),
  );

  $info['date_multiselect'] = array(
    'label' => t('Multiselect calendar'),
    'field types' => array('date', 'datestamp', 'datetime'),
  ) + $settings;

  return $info;
}

/**
 * Implements hook_field_widget_settings_form().
 */
function date_multiselect_field_widget_settings_form($field, $instance) {
  $settings = $instance['widget']['settings'];
  $form['numberOfMonths'] = array(
    '#title' => t('Number of months to display'),
    '#type' => 'textfield',
    '#default_value' => $settings['numberOfMonths'],
    '#element_validate' => array('element_validate_integer'),
  );
  $form['minDate'] = array(
    '#title' => t('Minimum date realtive to the current date'),
    '#type' => 'textfield',
    '#default_value' => $settings['minDate'],
    '#element_validate' => array('element_validate_number'),
  );
  $form['maxDate'] = array(
    '#title' => t('Maximum date realtive to the current date'),
    '#type' => 'textfield',
    '#default_value' => $settings['maxDate'],
    '#element_validate' => array('element_validate_number'),
  );
  $form['year_range'] = array(
    '#type' => 'date_year_range',
    '#default_value' => $settings['year_range'],
    '#fieldset' => 'date_format',
    '#weight' => 6,
  );

  return $form;
}

/**
 * Load needed files.
 *
 * Play nice with jQuery UI.
 */
function date_multiselect_add() {
  static $loaded = FALSE;
  if ($loaded) {
    return;
  }

  drupal_add_library('system', 'ui.datepicker');
  drupal_add_library('date_multiselect', 'multidatespicker');
  drupal_add_js(drupal_get_path('module', 'date_multiselect') . '/js/date_multiselect.js');

  $loaded = TRUE;
}

/**
 * Implements hook_library().
 */
function date_multiselect_library() {
  $libraries = array();

  $path = date_multiselect_get_multidatespicker_path();
  $libraries['multidatespicker'] = array(
    'title' => 'MultiDatesPicker',
    'website' => 'http://multidatespickr.sourceforge.net/',
    'version' => '1.6.3',
    'js' => array(
      $path . '/jquery-ui.multidatespicker.js' => array('group' => 'JS_LIBRARY'),
    ),
  );
  return $libraries;
}

/**
 * Get the location of the multidatespicker library.
 *
 * @return mixed
 *   The location of the library, or FALSE if the library isn't installed.
 */
function date_multiselect_get_multidatespicker_path() {
  if (function_exists('libraries_get_path')) {
    return libraries_get_path('multidatespicker');
  }

  // The following logic is taken from libraries_get_libraries()
  $searchdir = array();

  // Similar to 'modules' and 'themes' directories inside an installation
  // profile, installation profiles may want to place libraries into a
  // 'libraries' directory.
  $searchdir[] = 'profiles/' . drupal_get_profile() . '/libraries';

  // Always search sites/all/libraries.
  $searchdir[] = 'sites/all/libraries';

  // Also search sites/<domain>/*.
  $searchdir[] = conf_path() . '/libraries';

  foreach ($searchdir as $dir) {
    if (file_exists($dir . '/multidatespicker/jquery-ui.multidatespicker.js')) {
      return $dir . '/multidatespicker';
    }
  }

  return FALSE;
}

/**
 * Create a unique CSS id and output a single inline JS block for settings.
 *
 * Create a unique CSS id name and output a single inline JS block for
 * each startup function to call and settings array to pass it.  This
 * used to create a unique CSS class for each unique combination of
 * function and settings, but using classes requires a DOM traversal
 * and is much slower than an id lookup.  The new approach returns to
 * requiring a duplicate copy of the settings/code for every element
 * that uses them, but is much faster.  We could combine the logic by
 * putting the ids for each unique function/settings combo into
 * Drupal.settings and searching for each listed id.
 *
 * @param string $id
 *   The CSS class prefix to search the DOM for.
 * @param array $settings
 *   The settings array to pass to the jQuery function.
 *
 * @return string
 *   The CSS id to assign to the element.
 */
function date_multiselect_js_settings_id($id, array $settings) {
  static $js_added = FALSE;
  static $id_count = array();

  // Make sure multiselect date selector grid is in correct year.
  if (!empty($settings['yearRange'])) {
    $parts = explode(':', $settings['yearRange']);
    // Set the default date to 0 or the lowest bound.
    // Necessary for the datepicker to render and select dates correctly.
    $default_date = ($parts[0] > 0 || 0 > $parts[1]) ? $parts[0] : 0;
    $settings += array('defaultDate' => (string) $default_date . 'y');
  }

  if (!$js_added) {
    date_multiselect_add();
    $js_added = TRUE;
  }

  // We use a static array to account for possible multiple form_builder()
  // calls in the same request (form instance on 'Preview').
  if (!isset($id_count[$id])) {
    $id_count[$id] = 0;
  }

  $return_id = "$id-multiselect-" . $id_count[$id]++;
  $js_settings['dateMultiselect'][$return_id] = array(
    'settings' => $settings + array('altField' => 'input#' . $return_id),
  );
  drupal_add_js($js_settings, 'setting');
  return $return_id;
}

/**
 * Limit date granularity to year, month and day.
 */
function date_multiselect_date_format($format) {
  return (date_limit_format($format, array('year', 'month', 'day')));
}

/**
 * Implode the date values array into a comma separated string of dates.
 */
function date_multiselect_implode_dates($items, $format) {
  $return = '';
  foreach ($items as $item) {
    if ($item['value']) {
      $value = date(date_multiselect_date_format($format), $item['value']);
      $return = $return ? ("$return, $value") : $value;
    }
  }
  return $return;
}

/**
 * Implements hook_field_widget_form().
 */
function date_multiselect_field_widget_form(&$form, &$form_state, $field, $instance, $langcode, $items, $delta, $element) {
  module_load_include('inc', 'date_api', 'date_api_elements');
  $timezone = date_default_timezone();

  // TODO see if there's a way to keep the timezone element from ever being
  // nested as array('timezone' => 'timezone' => value)). After struggling
  // with this a while, I can find no way to get it displayed in the form
  // correctly and get it to use the timezone element without ending up
  // with nesting.
  if (is_array($timezone)) {
    $timezone = $timezone['timezone'];
  }

  $element += array(
    '#type' => 'textfield',
    '#weight' => $delta,
    '#size' => 50,
    '#maxlenght' => 255,
    '#date_timezone' => $timezone,
    '#date_format' => variable_get('date_format_short', 'm/d/Y - H:i'),
    '#element_validate' => array('date_multiselect_validate'),
    '#process' => array('date_multiselect_element_process'),
  );
  $element['#default_value'] = date_multiselect_implode_dates($items, $element['#date_format']);

  if ($field['settings']['tz_handling'] == 'date') {
    $element['timezone'] = array(
      '#type' => 'date_timezone',
      '#theme_wrappers' => array('date_timezone'),
      '#delta' => $delta,
      '#default_value' => $timezone,
      '#weight' => $instance['widget']['weight'] + 1,
      '#attributes' => array('class' => array('date-no-float')),
    );
  }

  return $element;
}

/**
 * Javascript multiselect element processing.
 *
 * Add multiselect attributes to the element and include JS files. This is done here
 * instead of on the hook_field_widget_form function to avoid not including the JS
 * when showing the form from cache (like after a validation error).
 */
function date_multiselect_element_process($element, &$form_state, $form) {
  $instance = field_widget_instance($element, $form_state);
  $field = field_widget_field($element, $form_state);
  $date = NULL;
  if (isset($element['#value'])) {
    $values = array_map('trim', explode(',', $element['#value']));
    $date = new DateObject(array_shift($values), $element['#date_timezone'], date_multiselect_date_format($element['#date_format']));
  }
  $range = date_range_years($instance['widget']['settings']['year_range'], $date);
  $year_range = date_range_string($range);

  $settings = array(
    'numberOfMonths' => (int) $instance['widget']['settings']['numberOfMonths'],
    'firstDay' => intval(variable_get('date_first_day', 0)),
    'dateFormat' => date_popup_format_to_popup(date_multiselect_date_format($element['#date_format']), 'datepicker'),
    'yearRange' => $year_range,
  );
  if (!empty($instance['widget']['settings']['minDate'])) {
    $settings['minDate'] = (int) $instance['widget']['settings']['minDate'];
  }
  if (!empty($instance['widget']['settings']['maxDate'])) {
    $settings['maxDate'] = (int) $instance['widget']['settings']['maxDate'];
  }
  if ($field['cardinality'] != '-1') {
    $settings['maxPicks'] = (int) $field['cardinality'];
  }

  // Create a unique id for each set of custom settings.
  $element['#id'] = date_multiselect_js_settings_id('multiselect-widget', $settings);

  return $element;
}

/**
 * Massage the input values back into a single date.
 *
 * When used as a Views widget, the validation step always gets triggered,
 * even with no form submission. Before form submission $element['#value']
 * contains a string, after submission it contains an array.
 */
function date_multiselect_validate($element, &$form_state) {
  $items = array();
  if ($element['#value']) {
    $values = array_map('trim', explode(',', $element['#value']));
    module_load_include('inc', 'date_api', 'date_api_elements');
    $format = date_multiselect_date_format($element['#date_format']);
    foreach ($values as $value) {
      $date = new DateObject($value, $element['#date_timezone'], $format);
      // If the date has errors, display them.
      // If something was input but there is no date, the date is invalid.
      // If the field is empty and required, set error message and return.
      if (empty($date) || !empty($date->errors)) {
        if (is_object($date) && !empty($date->errors)) {
          $message = t('The value input for field %field is invalid:', array('%field' => $element['#title']));
          $message .= '<br />' . implode('<br />', $date->errors);
          form_error($element, $message);
        }
        if (!empty($value)) {
          $message = t('The value input for field %field is invalid.', array('%field' => $element['#title']));
          form_error($element, $message);
        }
      }
      $items[] = array(
        'value' => $date->getTimestamp(),
        'timezone' => $element['#date_timezone'],
      );
    }

    if (empty($items) && $element['#required']) {
      $message = t('A valid date is required for %title.', array('%title' => $element['#title']));
      form_error($element, $message);
    }
  }

  form_set_value($element, $items, $form_state);
}

/**
 * Implements hook_field_widget_error().
 */
function date_multiselect_field_widget_error($element, $error, $form, &$form_state) {
  form_error($element, $error['message']);
}
